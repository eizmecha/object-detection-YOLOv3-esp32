<!--
PART 1/4 — PROPULSION + CORE PHYSICS SKELETON (NO FLIP FOUNDATION)

Goal of Part 1:
1) Remove the incorrect “LiftDrag-as-propeller” approach that causes rapid flipping.
2) Eliminate gyroscopic pitching from spinning rotor links (make rotors effectively massless).
3) Provide a clean, deterministic VTOL thrust interface using Gazebo Thrusters (force-based),
   so later parts can map ArduPilot (JSON/SITL) outputs to these thruster commands.

Important:
- This Part 1 is intentionally “physics-correct first”.
- Part 2 will connect ArduPilot outputs (JSON model) to the thruster command topics.
- Part 3 will add fixed-wing aero + elevons (LiftDrag on wing + control surfaces).
- Part 4 will add mission/digital twin interfacing + logging/telemetry + tuning.

Keep your meshes and positions: we reuse your rotor positions exactly.
-->

<?xml version="1.0"?>
<sdf version="1.9">
  <model name="super_hybrid_vtol">
    <!-- Spawn above ground -->
    <pose>0 0 0.30 0 0 0</pose>

    <!-- Recommended for flight sims -->
    <static>false</static>
    <self_collide>false</self_collide>

    <!-- ========================= -->
    <!-- BASE LINK (AIRFRAME BODY) -->
    <!-- ========================= -->
    <link name="base_link">
      <pose>0 0 0 0 0 0</pose>

      <!-- Mass/inertia: keep your values for now; refine later if needed -->
      <inertial>
        <pose>0 0 0 0 0 0</pose>
        <mass>2.45</mass>
        <inertia>
          <ixx>0.20</ixx>
          <ixy>0</ixy>
          <ixz>0</ixz>
          <iyy>0.15</iyy>
          <iyz>0</iyz>
          <izz>0.25</izz>
        </inertia>
      </inertial>

      <!-- Collision: keep simple -->
      <collision name="base_link_collision">
        <pose>0 0 -0.05 0 0 0</pose>
        <geometry>
          <box>
            <size>0.70 1.13 0.108</size>
          </box>
        </geometry>
        <surface>
          <friction>
            <ode>
              <mu>1.0</mu>
              <mu2>1.0</mu2>
            </ode>
          </friction>
          <contact>
            <ode>
              <kp>500000.0</kp>
              <kd>50.0</kd>
              <min_depth>0.001</min_depth>
            </ode>
          </contact>
        </surface>
      </collision>

      <!-- Visual mesh -->
      <visual name="base_link_visual">
        <pose>0 0 -0.38621 0 0 0</pose>
        <geometry>
          <mesh>
            <uri>model://super_hybrid_vtol/meshes/super_fus.STL</uri>
            <scale>1 1 1</scale>
          </mesh>
        </geometry>
      </visual>
    </link>

    <!-- ===================================================== -->
    <!-- VTOL MOTORS AS THRUSTERS (FORCE-BASED, NO GYRO FLIP)   -->
    <!-- ===================================================== -->
    <!--
      Why: Your flipping is dominated by rotor modeling.
      Fix: Thrusters apply force (N) directly to the rigid body, at the motor locations.
      This is stable and matches real VTOL physics: thrust vectors + moment arms.

      NOTE:
      - Thrusters listen to a command topic. In Part 2 we will connect ArduPilot JSON motor
        outputs to these topics.
      - For now, you can manually test each thruster using `gz topic -t ... -m ...`
        to confirm thrust directions and stability.

      Thrust sizing start point:
      - You stated ~1.4 kg at 80% throttle per motor.
      - Max per motor ≈ 1.4/0.8 = 1.75 kg ≈ 17.2 N.
      - Set max_thrust_per_motor ~ 18 N (conservative).
    -->

    <!-- Motor positions (relative to base_link) from your model -->
    <!-- front-right -->
    <frame name="motor_0_fr" attached_to="base_link">
      <pose>0.19257 -0.21068 -0.0045 0 0 0</pose>
    </frame>
    <!-- rear-left -->
    <frame name="motor_1_rl" attached_to="base_link">
      <pose>-0.33549 0.21128 -0.0045 0 0 0</pose>
    </frame>
    <!-- front-left -->
    <frame name="motor_2_fl" attached_to="base_link">
      <pose>0.19571 0.21128 -0.0045 0 0 0</pose>
    </frame>
    <!-- rear-right -->
    <frame name="motor_3_rr" attached_to="base_link">
      <pose>-0.33863 -0.21068 -0.0045 0 0 0</pose>
    </frame>

    <!-- Pusher position -->
    <frame name="motor_4_pusher" attached_to="base_link">
      <pose>-0.2953 0 -0.0065 0 0 0</pose>
    </frame>

    <!-- THRUSTER SYSTEMS -->
    <!-- Lift thrusters: +Z in your body frame (X fwd, Y left, Z up) -->
    <plugin filename="gz-sim-thruster-system" name="gz::sim::systems::Thruster">
      <link_name>base_link</link_name>
      <frame>motor_0_fr</frame>
      <direction>0 0 1</direction>
      <max_thrust>18.0</max_thrust>
      <topic>/super_hybrid_vtol/thrusters/motor0</topic>
    </plugin>

    <plugin filename="gz-sim-thruster-system" name="gz::sim::systems::Thruster">
      <link_name>base_link</link_name>
      <frame>motor_1_rl</frame>
      <direction>0 0 1</direction>
      <max_thrust>18.0</max_thrust>
      <topic>/super_hybrid_vtol/thrusters/motor1</topic>
    </plugin>

    <plugin filename="gz-sim-thruster-system" name="gz::sim::systems::Thruster">
      <link_name>base_link</link_name>
      <frame>motor_2_fl</frame>
      <direction>0 0 1</direction>
      <max_thrust>18.0</max_thrust>
      <topic>/super_hybrid_vtol/thrusters/motor2</topic>
    </plugin>

    <plugin filename="gz-sim-thruster-system" name="gz::sim::systems::Thruster">
      <link_name>base_link</link_name>
      <frame>motor_3_rr</frame>
      <direction>0 0 1</direction>
      <max_thrust>18.0</max_thrust>
      <topic>/super_hybrid_vtol/thrusters/motor3</topic>
    </plugin>

    <!-- Pusher thruster: +X forward thrust -->
    <plugin filename="gz-sim-thruster-system" name="gz::sim::systems::Thruster">
      <link_name>base_link</link_name>
      <frame>motor_4_pusher</frame>
      <direction>1 0 0</direction>
      <max_thrust>25.0</max_thrust>
      <topic>/super_hybrid_vtol/thrusters/pusher</topic>
    </plugin>

    <!-- ===================================================== -->
    <!-- VISUAL ROTORS ONLY (OPTIONAL, NO PHYSICS COUPLING)     -->
    <!-- ===================================================== -->
    <!--
      If you want spinning prop visuals later:
      - keep rotor links but set them as visuals only or extremely tiny inertia
      - do NOT use them for thrust
      We postpone spinning visuals to Part 4 to avoid reintroducing flip causes.
    -->

    <!-- ===================================================== -->
    <!-- SENSORS (KEPT) — CONNECTED IN PART 2 TO ARDUPILOT JSON -->
    <!-- ===================================================== -->
    <link name="imu_link">
      <pose relative_to="base_link">0 0 0 0 0 0</pose>
      <inertial>
        <mass>0.0001</mass>
        <inertia>
          <ixx>1e-9</ixx>
          <iyy>1e-9</iyy>
          <izz>1e-9</izz>
        </inertia>
      </inertial>

      <sensor name="imu_sensor" type="imu">
        <!-- Keep your orientation for now; we will validate in Part 2 -->
        <pose>0 0 0 3.141593 0 0</pose>
        <always_on>true</always_on>
        <update_rate>1000</update_rate>
      </sensor>

      <sensor name="mag_sensor" type="magnetometer">
        <always_on>true</always_on>
        <update_rate>100</update_rate>
      </sensor>

      <sensor name="air_speed" type="air_pressure">
        <always_on>true</always_on>
        <update_rate>100</update_rate>
        <pose>0.35 0 0.05 0 0 0</pose>
        <visualize>true</visualize>
      </sensor>
    </link>

    <joint name="imu_joint" type="fixed">
      <parent>base_link</parent>
      <child>imu_link</child>
    </joint>

    <sensor name="gps_sensor" type="gps">
      <always_on>true</always_on>
      <update_rate>10</update_rate>
    </sensor>

    <!-- Utility: joint state publisher (optional) -->
    <plugin filename="gz-sim-joint-state-publisher-system"
            name="gz::sim::systems::JointStatePublisher"/>

    <!--
      Part 2 will introduce:
      - ArduPilot JSON backend coupling to these sensors
      - mapping ArduPilot motor outputs to thruster topics
      - coordinate transform verification (ENU↔NED, FLU↔FRD)
    -->
    <!--
PART 2/4 — ARDUPILOT (ArduPlane QuadPlane, --model JSON) INTERFACE + MOTOR THRUST MODEL

Reason for Part 2 design choice:
- Your earlier “flip” came from using LiftDrag as a propeller model and from spinning-body gyro effects.
- Part 1 fixed the physics by moving to force-based propulsion.
- However, Gazebo’s Thruster system does NOT natively understand ArduPilot motor outputs.
- The clean professional approach (that stays inside SDF, no external bridge code) is:

  ArduPilotPlugin (libArduPilotPlugin.so)  --> commands rotor joint velocities
  gz-sim-multicopter-motor-model-system    --> converts joint velocities to thrust/torque (force-based)
  Sensors (IMU/GPS/Mag/Airspeed)           --> fed back to ArduPilotPlugin

This keeps your current workflow (GZ_SIM_SYSTEM_PLUGIN_PATH + --model JSON) and removes the cause of flipping.

How to use this Part 2:
- Apply it on top of Part 1 by:
  A) Removing the 5 Thruster plugins from Part 1
  B) Adding the rotor links/joints below (massless)
  C) Adding the MotorModel plugins below (real thrust)
  D) Adding the ArduPilotPlugin block below (controls + sensors)

NOTE:
- Keep your wing/elevon LiftDrag for Part 3 (fixed-wing aero). Part 2 focuses on VTOL stability.
-->

<!-- =============================== -->
<!-- ROTOR LINKS + JOINTS (MASSLESS) -->
<!-- =============================== -->

<!-- Rotor 0: front-right (CCW) -->
<link name="rotor_0">
  <pose relative_to="base_link">0.19257 -0.21068 -0.0045 0 0 0</pose>
  <inertial>
    <mass>0.001</mass>
    <inertia>
      <ixx>1e-7</ixx><iyy>1e-7</iyy><izz>1e-7</izz>
    </inertia>
  </inertial>
  <visual name="rotor_0_visual">
    <pose>-0.0070034310 -0.0647861960 -0.0065644327 0 0 0</pose>
    <geometry>
      <mesh>
        <uri>model://super_hybrid_vtol/meshes/vtol_prop_ccw.STL</uri>
        <scale>1 1 1</scale>
      </mesh>
    </geometry>
  </visual>
</link>

<joint name="rotor_0_joint" type="revolute">
  <parent>base_link</parent>
  <child>rotor_0</child>
  <axis>
    <xyz>0 0 1</xyz>
    <limit><lower>-1e16</lower><upper>1e16</upper></limit>
    <dynamics><damping>0.001</damping></dynamics>
  </axis>
</joint>

<!-- Rotor 1: rear-left (CCW) -->
<link name="rotor_1">
  <pose relative_to="base_link">-0.33549 0.21128 -0.0045 0 0 0</pose>
  <inertial>
    <mass>0.001</mass>
    <inertia>
      <ixx>1e-7</ixx><iyy>1e-7</iyy><izz>1e-7</izz>
    </inertia>
  </inertial>
  <visual name="rotor_1_visual">
    <pose>-0.0070034310 -0.0647861960 -0.0065644327 0 0 0</pose>
    <geometry>
      <mesh>
        <uri>model://super_hybrid_vtol/meshes/vtol_prop_ccw.STL</uri>
        <scale>1 1 1</scale>
      </mesh>
    </geometry>
  </visual>
</link>

<joint name="rotor_1_joint" type="revolute">
  <parent>base_link</parent>
  <child>rotor_1</child>
  <axis>
    <xyz>0 0 1</xyz>
    <limit><lower>-1e16</lower><upper>1e16</upper></limit>
    <dynamics><damping>0.001</damping></dynamics>
  </axis>
</joint>

<!-- Rotor 2: front-left (CW) -->
<link name="rotor_2">
  <pose relative_to="base_link">0.19571 0.21128 -0.0045 0 0 0</pose>
  <inertial>
    <mass>0.001</mass>
    <inertia>
      <ixx>1e-7</ixx><iyy>1e-7</iyy><izz>1e-7</izz>
    </inertia>
  </inertial>
  <visual name="rotor_2_visual">
    <pose>-0.0070594754 -0.0647858828 -0.0066520433 0 0 0</pose>
    <geometry>
      <mesh>
        <uri>model://super_hybrid_vtol/meshes/vtol_prop_cw.STL</uri>
        <scale>1 1 1</scale>
      </mesh>
    </geometry>
  </visual>
</link>

<joint name="rotor_2_joint" type="revolute">
  <parent>base_link</parent>
  <child>rotor_2</child>
  <axis>
    <xyz>0 0 1</xyz>
    <limit><lower>-1e16</lower><upper>1e16</upper></limit>
    <dynamics><damping>0.001</damping></dynamics>
  </axis>
</joint>

<!-- Rotor 3: rear-right (CW) -->
<link name="rotor_3">
  <pose relative_to="base_link">-0.33863 -0.21068 -0.0045 0 0 0</pose>
  <inertial>
    <mass>0.001</mass>
    <inertia>
      <ixx>1e-7</ixx><iyy>1e-7</iyy><izz>1e-7</izz>
    </inertia>
  </inertial>
  <visual name="rotor_3_visual">
    <pose>-0.0070594754 -0.0647858828 -0.0066520433 0 0 0</pose>
    <geometry>
      <mesh>
        <uri>model://super_hybrid_vtol/meshes/vtol_prop_cw.STL</uri>
        <scale>1 1 1</scale>
      </mesh>
    </geometry>
  </visual>
</link>

<joint name="rotor_3_joint" type="revolute">
  <parent>base_link</parent>
  <child>rotor_3</child>
  <axis>
    <xyz>0 0 1</xyz>
    <limit><lower>-1e16</lower><upper>1e16</upper></limit>
    <dynamics><damping>0.001</damping></dynamics>
  </axis>
</joint>

<!-- Pusher rotor (visual + joint about X axis) -->
<link name="rotor_pusher">
  <pose relative_to="base_link">-0.2953 0 -0.0065 0 0 0</pose>
  <inertial>
    <mass>0.002</mass>
    <inertia>
      <ixx>2e-7</ixx><iyy>2e-7</iyy><izz>2e-7</izz>
    </inertia>
  </inertial>
  <visual name="rotor_pusher_visual">
    <pose>-0.0075749999 -0.0125011178 -0.1267471462 0 0 0</pose>
    <geometry>
      <mesh>
        <uri>model://super_hybrid_vtol/meshes/super_pusher_prop.STL</uri>
        <scale>1 1 1</scale>
      </mesh>
    </geometry>
  </visual>
</link>

<joint name="rotor_pusher_joint" type="revolute">
  <parent>base_link</parent>
  <child>rotor_pusher</child>
  <axis>
    <xyz>1 0 0</xyz>
    <limit><lower>-1e16</lower><upper>1e16</upper></limit>
    <dynamics><damping>0.001</damping></dynamics>
  </axis>
</joint>

<!-- ====================================================== -->
<!-- MOTOR THRUST MODEL (FORCE-BASED, STABLE, NO LiftDrag)  -->
<!-- ====================================================== -->
<!--
  These plugins are the key to eliminating flips:
  - They compute thrust from joint angular velocity and apply forces/torques to base_link.

  Starting constants (you can tune later with real bench thrust curves):
  - Your claim: ~17.2 N max thrust per lift motor (approx).
  - We set motor_constant so that max thrust is reached near ~2200 rad/s.
    motor_constant ≈ 17.2 / (2200^2) ≈ 3.55e-6

  - moment_constant is smaller; start ~1e-7 to provide yaw authority.
-->

<!-- Lift motor 0 (CCW) -->
<plugin filename="gz-sim-multicopter-motor-model-system"
        name="gz::sim::systems::MulticopterMotorModel">
  <joint_name>rotor_0_joint</joint_name>
  <link_name>base_link</link_name>
  <turning_direction>ccw</turning_direction>
  <motor_constant>3.6e-6</motor_constant>
  <moment_constant>1.0e-7</moment_constant>
  <max_rot_velocity>2200</max_rot_velocity>
  <time_constant_up>0.02</time_constant_up>
  <time_constant_down>0.04</time_constant_down>
  <rotor_drag_coefficient>1.0e-6</rotor_drag_coefficient>
  <rolling_moment_coefficient>1.0e-7</rolling_moment_coefficient>
</plugin>

<!-- Lift motor 1 (CCW) -->
<plugin filename="gz-sim-multicopter-motor-model-system"
        name="gz::sim::systems::MulticopterMotorModel">
  <joint_name>rotor_1_joint</joint_name>
  <link_name>base_link</link_name>
  <turning_direction>ccw</turning_direction>
  <motor_constant>3.6e-6</motor_constant>
  <moment_constant>1.0e-7</moment_constant>
  <max_rot_velocity>2200</max_rot_velocity>
  <time_constant_up>0.02</time_constant_up>
  <time_constant_down>0.04</time_constant_down>
  <rotor_drag_coefficient>1.0e-6</rotor_drag_coefficient>
  <rolling_moment_coefficient>1.0e-7</rolling_moment_coefficient>
</plugin>

<!-- Lift motor 2 (CW) -->
<plugin filename="gz-sim-multicopter-motor-model-system"
        name="gz::sim::systems::MulticopterMotorModel">
  <joint_name>rotor_2_joint</joint_name>
  <link_name>base_link</link_name>
  <turning_direction>cw</turning_direction>
  <motor_constant>3.6e-6</motor_constant>
  <moment_constant>1.0e-7</moment_constant>
  <max_rot_velocity>2200</max_rot_velocity>
  <time_constant_up>0.02</time_constant_up>
  <time_constant_down>0.04</time_constant_down>
  <rotor_drag_coefficient>1.0e-6</rotor_drag_coefficient>
  <rolling_moment_coefficient>1.0e-7</rolling_moment_coefficient>
</plugin>

<!-- Lift motor 3 (CW) -->
<plugin filename="gz-sim-multicopter-motor-model-system"
        name="gz::sim::systems::MulticopterMotorModel">
  <joint_name>rotor_3_joint</joint_name>
  <link_name>base_link</link_name>
  <turning_direction>cw</turning_direction>
  <motor_constant>3.6e-6</motor_constant>
  <moment_constant>1.0e-7</moment_constant>
  <max_rot_velocity>2200</max_rot_velocity>
  <time_constant_up>0.02</time_constant_up>
  <time_constant_down>0.04</time_constant_down>
  <rotor_drag_coefficient>1.0e-6</rotor_drag_coefficient>
  <rolling_moment_coefficient>1.0e-7</rolling_moment_coefficient>
</plugin>

<!-- Pusher motor model (thrust along +X due to joint axis = X) -->
<plugin filename="gz-sim-multicopter-motor-model-system"
        name="gz::sim::systems::MulticopterMotorModel">
  <joint_name>rotor_pusher_joint</joint_name>
  <link_name>base_link</link_name>
  <turning_direction>cw</turning_direction>
  <!-- Larger prop -> larger thrust; start higher and tune later -->
  <motor_constant>8.0e-6</motor_constant>
  <moment_constant>0.0</moment_constant>
  <max_rot_velocity>1600</max_rot_velocity>
  <time_constant_up>0.05</time_constant_up>
  <time_constant_down>0.08</time_constant_down>
  <rotor_drag_coefficient>1.0e-6</rotor_drag_coefficient>
  <rolling_moment_coefficient>0.0</rolling_moment_coefficient>
</plugin>

<!-- ===================================================== -->
<!-- ARDUPILOTPLUGIN: SENSORS + ACTUATOR COMMANDS TO JOINTS -->
<!-- ===================================================== -->
<!--
  Key fixes vs your previous file:
  - REMOVE ALL LiftDrag on rotors (done above).
  - Elevon offsets set to 0 (no startup trim torque).
  - Motor cmd_max increased to realistic rad/s for props.
  - Multiplier scales PWM to rad/s command. Start conservative; tune later.
  - Remove the stray “s” after </plugin> (syntax).

  Your workflow remains:
    sim_vehicle.py -v ArduPlane -f quadplane --model JSON --console --map
-->

<plugin name="ArduPilotPlugin" filename="libArduPilotPlugin.so">
  <connectionTimeoutMaxCount>5</connectionTimeoutMaxCount>
  <lock_step>1</lock_step>

  <!-- Transforms: keep your current working values for now -->
  <modelXYZToAirplaneXForwardZDown degrees="true">
    0 0 0 180 0 0
  </modelXYZToAirplaneXForwardZDown>
  <gazeboXYZToNED degrees="true">
    0 0 0 180 0 90
  </gazeboXYZToNED>

  <sensors>
    <imu>imu_sensor</imu>
    <gps>gps_sensor</gps>
    <magnetometer>mag_sensor</magnetometer>
    <air_pressure>air_speed</air_pressure>
  </sensors>

  <!-- Elevons: keep POSITION, remove offset -->
  <control channel="0">
    <jointName>left_elevon_joint</jointName>
    <useForce>1</useForce>
    <multiplier>1.0</multiplier>
    <offset>0</offset>
    <servo_min>1000</servo_min>
    <servo_max>2000</servo_max>
    <type>POSITION</type>
    <p_gain>8.0</p_gain>
  </control>

  <control channel="1">
    <jointName>right_elevon_joint</jointName>
    <useForce>1</useForce>
    <multiplier>1.0</multiplier>
    <offset>0</offset>
    <servo_min>1000</servo_min>
    <servo_max>2000</servo_max>
    <type>POSITION</type>
    <p_gain>8.0</p_gain>
  </control>

  <!-- Pusher motor (channel 2): VELOCITY rad/s -->
  <control channel="2">
    <jointName>rotor_pusher_joint</jointName>
    <useForce>1</useForce>
    <!-- PWM->rad/s scale (start conservative; tune later) -->
    <multiplier>1.6</multiplier>
    <offset>0</offset>
    <servo_min>1000</servo_min>
    <servo_max>2000</servo_max>
    <type>VELOCITY</type>
    <p_gain>0.20</p_gain>
    <cmd_max>1600</cmd_max>
    <cmd_min>0</cmd_min>
  </control>

  <!-- VTOL lift motors: channels 4..7 (your confirmed mapping), VELOCITY rad/s -->
  <control channel="4">
    <jointName>rotor_0_joint</jointName>
    <useForce>1</useForce>
    <multiplier>2.2</multiplier>
    <offset>0</offset>
    <servo_min>1000</servo_min>
    <servo_max>2000</servo_max>
    <type>VELOCITY</type>
    <p_gain>0.15</p_gain>
    <cmd_max>2200</cmd_max>
    <cmd_min>0</cmd_min>
  </control>

  <control channel="5">
    <jointName>rotor_1_joint</jointName>
    <useForce>1</useForce>
    <multiplier>2.2</multiplier>
    <offset>0</offset>
    <servo_min>1000</servo_min>
    <servo_max>2000</servo_max>
    <type>VELOCITY</type>
    <p_gain>0.15</p_gain>
    <cmd_max>2200</cmd_max>
    <cmd_min>0</cmd_min>
  </control>

  <control channel="6">
    <jointName>rotor_2_joint</jointName>
    <useForce>1</useForce>
    <multiplier>2.2</multiplier>
    <offset>0</offset>
    <servo_min>1000</servo_min>
    <servo_max>2000</servo_max>
    <type>VELOCITY</type>
    <p_gain>0.15</p_gain>
    <cmd_max>2200</cmd_max>
    <cmd_min>0</cmd_min>
  </control>

  <control channel="7">
    <jointName>rotor_3_joint</jointName>
    <useForce>1</useForce>
    <multiplier>2.2</multiplier>
    <offset>0</offset>
    <servo_min>1000</servo_min>
    <servo_max>2000</servo_max>
    <type>VELOCITY</type>
    <p_gain>0.15</p_gain>
    <cmd_max>2200</cmd_max>
    <cmd_min>0</cmd_min>
  </control>
</plugin>

<!-- ===================================================== -->
<!-- REQUIRED UTILITY SYSTEMS                               -->
<!-- ===================================================== -->
<plugin filename="gz-sim-joint-state-publisher-system"
        name="gz::sim::systems::JointStatePublisher"/>
    <!--
PART 3/4 — FIXED-WING AERODYNAMICS + ELEVONS (S5020-BASED) FOR QUADPLANE

Goal of Part 3:
1) Add stable, conservative fixed-wing aerodynamic forces for cruise (70–90 km/h).
2) Add elevon control-surface aerodynamic effect coupled to elevon joint angles.
3) Keep VTOL propulsion from Part 2 unchanged (MulticopterMotorModel on rotors).
4) Ensure the model can: VTOL takeoff → transition → fixed-wing cruise → VTOL land.

Important rules (to avoid reintroducing flip):
- DO NOT use LiftDrag on the VTOL rotors or the pusher prop. (MotorModel already handles thrust.)
- LiftDrag is used ONLY for wing/body aerodynamic lift+drag and for control surfaces (elevons).
- Keep elevon ArduPilotPlugin POSITION controls from Part 2 (offset=0).

Where to put this:
- Insert these blocks into your super_hybrid_vtol.sdf:
  - Wing/body LiftDrag plugin: inside <model> (applies to base_link)
  - Elevon links/joints (if you already have them, keep yours but verify axes)
  - Elevon LiftDrag control plugins: inside <model> (applies to base_link)

Units:
- a0, alpha_stall in radians
- cla in 1/rad
-->

<!-- ========================================================= -->
<!-- 3A) BODY/WING AERODYNAMICS (APPLIED TO base_link)         -->
<!-- ========================================================= -->
<!--
Tuning targets from your capstone:
- Cruise band: 70–90 km/h (≈ 19.4–25 m/s)
- Best efficiency AoA: 2–4 deg (≈ 0.035–0.070 rad)
- Wing area: 31 dm^2 = 0.31 m^2

This LiftDrag provides:
- Lift along +Z (your body frame Z-up)
- Drag opposite +X airspeed (through LiftDrag forward vector)
-->

<plugin filename="gz-sim-lift-drag-system" name="gz::sim::systems::LiftDrag">
  <!-- Cambered airfoil => small positive a0 (zero-lift AoA slightly negative);
       Here we use a modest a0 to avoid pitch surprises. -->
  <a0>0.03</a0>                 <!-- rad -->
  <cla>4.25</cla>               <!-- 1/rad (conservative low-Re wing) -->
  <cda>0.04</cda>               <!-- baseline drag; start conservative -->
  <cma>0.0</cma>                <!-- keep neutral initially -->

  <!-- Stall behavior (conservative) -->
  <alpha_stall>0.28</alpha_stall>   <!-- ~16 deg -->
  <cla_stall>0.0</cla_stall>
  <cda_stall>0.9</cda_stall>

  <!-- Reference area -->
  <area>0.31</area>

  <air_density>1.2041</air_density>

  <!-- Body axes: X forward, Z up -->
  <forward>1 0 0</forward>
  <upward>0 0 1</upward>

  <!-- Apply aero forces to base_link -->
  <link_name>base_link</link_name>

  <!-- Center of pressure location relative to CG origin.
       Your CG origin is 0,0,0; CP typically slightly behind CG on a wing.
       Start slightly aft to reduce pitch-up tendency. -->
  <cp>-0.06 0 0</cp>
</plugin>

<!-- Optional: add a small pure-drag term to represent fuselage/booms (stability in transition) -->
<plugin filename="gz-sim-lift-drag-system" name="gz::sim::systems::LiftDrag">
  <a0>0.0</a0>
  <cla>0.0</cla>
  <cda>0.08</cda>              <!-- “parasite drag” -->
  <alpha_stall>0.52</alpha_stall>
  <cla_stall>0.0</cla_stall>
  <cda_stall>0.2</cda_stall>
  <area>0.06</area>            <!-- effective frontal area proxy -->
  <air_density>1.2041</air_density>
  <forward>1 0 0</forward>
  <upward>0 0 1</upward>
  <link_name>base_link</link_name>
  <cp>0 0 0</cp>
</plugin>

<!-- ========================================================= -->
<!-- 3B) ELEVONS (LINKS + JOINTS)                              -->
<!-- ========================================================= -->
<!--
If you already have left_elevon/right_elevon links and joints from your older SDF,
keep them ONLY if:
- hinge axis is correct
- joint limits are reasonable (±25–30 deg)
- no large “pose roll/yaw” offsets that change hinge direction unexpectedly

Recommended hinge axis for elevons on a flying wing:
- Along local span axis (roughly body Y) if modeled as simple hinge.
You currently used xyz 0 1 0 — keep that if the geometry matches.
-->

<!-- LEFT ELEVON LINK (keep your geometry/mesh as-is) -->
<link name="left_elevon">
  <pose relative_to="base_link">-0.25000 0.36434 -0.0030 0 0 0</pose>
  <inertial>
    <mass>0.02</mass>
    <inertia>
      <ixx>1e-4</ixx><iyy>1e-4</iyy><izz>1e-4</izz>
    </inertia>
  </inertial>
  <visual name="left_elevon_visual">
    <pose>-0.0251825455 -0.1564833790 -0.0048282174 0 0 0</pose>
    <geometry>
      <mesh>
        <uri>model://super_hybrid_vtol/meshes/super_elevon_left.STL</uri>
        <scale>1 1 1</scale>
      </mesh>
    </geometry>
  </visual>
</link>

<joint name="left_elevon_joint" type="revolute">
  <parent>base_link</parent>
  <child>left_elevon</child>
  <axis>
    <xyz>0 1 0</xyz>
    <limit>
      <lower>-0.45</lower>      <!-- ~-26 deg -->
      <upper>0.45</upper>       <!-- ~+26 deg -->
    </limit>
    <dynamics>
      <damping>3.0</damping>
      <spring_stiffness>60.0</spring_stiffness>
    </dynamics>
  </axis>
</joint>

<!-- RIGHT ELEVON LINK -->
<link name="right_elevon">
  <pose relative_to="base_link">-0.25000 -0.36434 -0.0030 0 0 0</pose>
  <inertial>
    <mass>0.02</mass>
    <inertia>
      <ixx>1e-4</ixx><iyy>1e-4</iyy><izz>1e-4</izz>
    </inertia>
  </inertial>
  <visual name="right_elevon_visual">
    <pose>-0.0233319545 -0.1552907338 -0.0049171962 0 0 0</pose>
    <geometry>
      <mesh>
        <uri>model://super_hybrid_vtol/meshes/super_elevon_right.STL</uri>
        <scale>1 1 1</scale>
      </mesh>
    </geometry>
  </visual>
</link>

<joint name="right_elevon_joint" type="revolute">
  <parent>base_link</parent>
  <child>right_elevon</child>
  <axis>
    <xyz>0 1 0</xyz>
    <limit>
      <lower>-0.45</lower>
      <upper>0.45</upper>
    </limit>
    <dynamics>
      <damping>3.0</damping>
      <spring_stiffness>60.0</spring_stiffness>
    </dynamics>
  </axis>
</joint>

<!-- ========================================================= -->
<!-- 3C) ELEVON AERODYNAMIC EFFECT (CONTROLLED BY JOINT ANGLE) -->
<!-- ========================================================= -->
<!--
We apply control-surface effect to base_link using control_joint_name.
This produces differential lift (roll) and collective lift change (pitch).

Key tuning parameter:
- control_joint_rad_to_cl
  magnitude sets how strong elevons are.
  start modest to avoid oscillations during transition.
-->

<!-- LEFT ELEVON AERO -->
<plugin filename="gz-sim-lift-drag-system" name="gz::sim::systems::LiftDrag">
  <a0>0.0</a0>
  <cla>5.5</cla>
  <cda>0.03</cda>

  <alpha_stall>0.35</alpha_stall>
  <cla_stall>0.0</cla_stall>
  <cda_stall>0.6</cda_stall>

  <area>0.035</area>           <!-- elevon effective area -->
  <air_density>1.2041</air_density>

  <forward>1 0 0</forward>
  <upward>0 0 1</upward>

  <link_name>base_link</link_name>
  <cp>-0.28 0.33 0</cp>         <!-- approximate elevon region -->

  <control_joint_name>left_elevon_joint</control_joint_name>

  <!-- Sign convention:
     +joint angle should correspond to “trailing edge down” OR “up” depending on your mesh/joint.
     If roll/pitch are reversed in flight, flip this sign (+/-).
  -->
  <control_joint_rad_to_cl>2.8</control_joint_rad_to_cl>
</plugin>

<!-- RIGHT ELEVON AERO -->
<plugin filename="gz-sim-lift-drag-system" name="gz::sim::systems::LiftDrag">
  <a0>0.0</a0>
  <cla>5.5</cla>
  <cda>0.03</cda>

  <alpha_stall>0.35</alpha_stall>
  <cla_stall>0.0</cla_stall>
  <cda_stall>0.6</cda_stall>

  <area>0.035</area>
  <air_density>1.2041</air_density>

  <forward>1 0 0</forward>
  <upward>0 0 1</upward>

  <link_name>base_link</link_name>
  <cp>-0.28 -0.33 0</cp>

  <control_joint_name>right_elevon_joint</control_joint_name>
  <control_joint_rad_to_cl>2.8</control_joint_rad_to_cl>
</plugin>

<!-- ========================================================= -->
<!-- 3D) NOTES FOR YOUR GUIDED/QLOITER WORKFLOW                -->
<!-- ========================================================= -->
<!--
After Part 3:
- VTOL hover should be stable (Part 2 propulsion)
- Forward flight lift/drag will appear when airspeed increases
- During transition, keep initial tuning conservative:
  - start with low pusher throttle
  - ensure airspeed sensor is valid (MS4525DO model in sim)
  - confirm pitch is not inverted (transform correctness)

If pitch is inverted:
- do NOT change geometry; adjust the transform or IMU pose in Part 4.
-->
```0
    <!--
PART 4/4 — CAPSTONE “PROFESSIONAL FINISH”
A) Simulation robustness: physics settings, sensors (noise/frames), logging hooks
B) QGroundControl mission workflow readiness (GUIDED/QLOITER/AUTO/transition)
C) Digital twin (real-time mirror): MAVLink telemetry → Gazebo pose update (external bridge)

Important:
- Part 4 includes BOTH:
  (1) SDF additions (Gazebo-side logging and sensor realism)
  (2) A Python “Digital Twin Bridge” script (runs outside Gazebo) to mirror real UAV into Gazebo

This matches your capstone requirement:
- same vehicle model can be used for SITL testing and for real-flight mirroring.
-->

<!-- ========================================================= -->
<!-- 4A) PHYSICS + SIM STABILITY SETTINGS (ADD INSIDE <model>) -->
<!-- ========================================================= -->
<!--
These reduce “numerical flip” and improve lock-step performance.
Keep lock_step=1 in ArduPilotPlugin as you already do.
-->

<plugin filename="gz-sim-physics-system" name="gz::sim::systems::Physics">
  <!-- conservative real-time constraints -->
  <max_step_size>0.001</max_step_size>      <!-- 1 kHz physics step -->
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>0</real_time_update_rate>
</plugin>

<!-- Optional: aerodynamic damping to reduce unrealistic oscillations in early tuning -->
<plugin filename="gz-sim-aerodynamics-system" name="gz::sim::systems::Aerodynamics">
  <!-- If your install doesn't include this plugin, remove safely. -->
</plugin>

<!-- ========================================================= -->
<!-- 4B) SENSORS — ADD REALISTIC NOISE + FIXED FRAME NAMING    -->
<!-- ========================================================= -->
<!--
Your stack: ArduPlane QuadPlane --model JSON + libArduPilotPlugin.so
So the sensor names must match exactly what ArduPilotPlugin references.

Keep your sensors, but add noise blocks (minimal, not extreme).
Insert/replace your existing sensor blocks with these patterns.

NOTE:
- Some noise blocks differ slightly across Gazebo versions. If a noise tag is rejected,
  remove only the noise tag, keep the sensor.
-->

<!-- IMU SENSOR (inside imu_link) -->
<!-- Example: add noise to gyro/accel -->
<!--
<sensor name="imu_sensor" type="imu">
  <pose>0 0 0 3.141593 0 0</pose>
  <always_on>true</always_on>
  <update_rate>1000</update_rate>
  <imu>
    <angular_velocity>
      <x><noise type="gaussian"><mean>0</mean><stddev>0.0008</stddev></noise></x>
      <y><noise type="gaussian"><mean>0</mean><stddev>0.0008</stddev></noise></y>
      <z><noise type="gaussian"><mean>0</mean><stddev>0.0008</stddev></noise></z>
    </angular_velocity>
    <linear_acceleration>
      <x><noise type="gaussian"><mean>0</mean><stddev>0.02</stddev></noise></x>
      <y><noise type="gaussian"><mean>0</mean><stddev>0.02</stddev></noise></y>
      <z><noise type="gaussian"><mean>0</mean><stddev>0.02</stddev></noise></z>
    </linear_acceleration>
  </imu>
</sensor>
-->

<!-- GPS SENSOR (inside base_link or model scope) -->
<!--
<sensor name="gps_sensor" type="gps">
  <always_on>true</always_on>
  <update_rate>10</update_rate>
  <gps>
    <position_sensing>
      <horizontal>
        <noise type="gaussian"><mean>0</mean><stddev>0.7</stddev></noise>
      </horizontal>
      <vertical>
        <noise type="gaussian"><mean>0</mean><stddev>1.2</stddev></noise>
      </vertical>
    </position_sensing>
  </gps>
</sensor>
-->

<!-- AIRSPEED SENSOR (air_pressure) -->
<!--
<sensor name="air_speed" type="air_pressure">
  <always_on>true</always_on>
  <update_rate>50</update_rate>
  <pose>0.35 0 0.05 0 0 0</pose>
  <air_pressure>
    <pressure>
      <noise type="gaussian"><mean>0</mean><stddev>0.3</stddev></noise>
    </pressure>
  </air_pressure>
</sensor>
-->

<!-- ========================================================= -->
<!-- 4C) LOGGING / DATA EXPORT (ADD INSIDE <model>)            -->
<!-- ========================================================= -->
<!--
For capstone evidence you want repeatable logs of:
- pose/attitude
- airspeed
- motor commands / rotor joint states
- mission state (from MAVLink)

Gazebo-side: log selected topics to a bag.
ArduPilot-side: you already have MAVProxy console and can record tlogs.

Gazebo Transport logging:
- The recorder is usually started from CLI. But we include TopicPublisher systems where useful.
-->

<plugin filename="gz-sim-pose-publisher-system"
        name="gz::sim::systems::PosePublisher">
  <publish_link_pose>true</publish_link_pose>
  <publish_model_pose>true</publish_model_pose>
  <update_frequency>50</update_frequency>
</plugin>

<plugin filename="gz-sim-joint-state-publisher-system"
        name="gz::sim::systems::JointStatePublisher"/>

<!-- ========================================================= -->
<!-- 4D) QGC + SITL WORKFLOW (NOT CODE, BUT REQUIRED SETTINGS) -->
<!-- ========================================================= -->
<!--
Your current commands:
- sim_vehicle.py -v ArduPlane -f quadplane --model JSON --console --map
- mode GUIDED ; arm throttle ; takeoff 10
- QLOITER

Professional workflow additions:
1) Use QGroundControl to:
   - confirm vehicle type is Plane/QuadPlane
   - calibrate (in sim) and confirm sensors healthy
2) For transition tests:
   - start in QHOVER or QLOITER
   - climb to 15–25 m
   - command QTRANSITION or AUTO mission with a VTOL transition step
3) For AUTO missions:
   - VTOL takeoff -> waypoint -> transition -> fixed-wing legs -> VTOL landing
4) Always validate airspeed sensor in-flight; transition relies on it.

(Part 4 provides the “digital twin” piece next.)
-->
  </model>
</sdf>
